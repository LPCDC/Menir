from __future__ import annotations
from pathlib import Path
import datetime as dt
import hashlib, importlib, importlib.util, json, os, subprocess
from typing import Dict, List
from urllib import request as urllib_request
from urllib.error import HTTPError, URLError

ROOT = Path(__file__).resolve().parents[1]
ENV = ROOT / ".env"
LOG = ROOT / "logs" / "operations.jsonl"
CHECKPOINT = ROOT / "artifacts" / "itau" / "checkpoint.md"
LOG.parent.mkdir(parents=True, exist_ok=True)
CHECKPOINT.parent.mkdir(parents=True, exist_ok=True)

ENV_TEMPLATE = """# Generated by scripts/boot_now.py
NEO4J_URI=bolt://localhost:7687
NEO4J_USER=neo4j
NEO4J_PASSWORD=changeme
"""

def sha256(path: Path) -> str:
    return hashlib.sha256(path.read_bytes()).hexdigest()

def run(cmd: str, cwd: Path = ROOT) -> str:
    r = subprocess.run(cmd, cwd=cwd, shell=True, capture_output=True, text=True)
    if r.returncode != 0:
        raise RuntimeError(r.stderr.strip() or r.stdout.strip())
    return r.stdout.strip()

def _load_requests():
    spec = importlib.util.find_spec("requests")
    return None if spec is None else importlib.import_module("requests")

def notify_grok(payload: dict) -> Dict[str, str]:
    url = os.getenv("GROK_WEBHOOK_URL", "http://localhost:5000/mcp/tool")
    token = os.getenv("GROK_TOKEN", "menir-local-token")
    headers = {"Authorization": f"Bearer {token}", "Content-Type": "application/json"}

    req_mod = _load_requests()
    if req_mod is not None:
        try:
            resp = req_mod.post(url, headers=headers, json=payload, timeout=10)
            return {"status": resp.status_code, "text": resp.text[:200]}
        except Exception as e:
            return {"status": "error", "text": str(e)}

    data = json.dumps(payload).encode("utf-8")
    req = urllib_request.Request(url, data=data, headers=headers, method="POST")
    try:
        with urllib_request.urlopen(req, timeout=10) as resp:
            return {"status": resp.status, "text": resp.read(200).decode("utf-8", "replace")}
    except (HTTPError, URLError, TimeoutError, ValueError) as e:
        return {"status": "error", "text": str(e)}

def detect_boot_trigger(user_input: str) -> bool:
    if not user_input:
        return False
    normalized = "".join(ch.lower() for ch in user_input if not ch.isspace())
    triggers = {"bootnow", "boot", "boot!", "nootnow", "boornow"}
    return normalized in triggers

def ensure_env() -> bool:
    if ENV.exists():
        return False
    ENV.write_text(ENV_TEMPLATE, encoding="utf-8")
    return True

def append_log(entry: dict) -> None:
    with LOG.open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(entry, ensure_ascii=False) + "\n")

def perform_healthchecks() -> List[Dict[str, str]]:
    checks: List[Dict[str, str]] = []
    # python
    try:
        checks.append({"check": "python --version", "status": "ok", "output": run("python --version")})
    except Exception as e:
        checks.append({"check": "python --version", "status": "error", "output": str(e)})
    # dirs
    for rel in ("artifacts", "neo4j", "projects"):
        p = ROOT / rel
        name = f"ls {rel}"
        try:
            if p.exists():
                out = " ".join(sorted(ch.name for ch in p.iterdir())) or "<empty>"
                checks.append({"check": name, "status": "ok", "output": out})
            else:
                checks.append({"check": name, "status": "skipped", "output": "directory missing"})
        except Exception as e:
            checks.append({"check": name, "status": "error", "output": str(e)})
    # requests
    try:
        importlib.import_module("requests")
        checks.append({"check": "import requests", "status": "ok", "output": "available"})
    except Exception as e:
        checks.append({"check": "import requests", "status": "skipped", "output": str(e)})
    return checks

def main() -> None:
    ts = dt.datetime.now(dt.timezone.utc).isoformat()
    env_created = ensure_env()
    if not CHECKPOINT.exists():
        CHECKPOINT.write_text("# checkpoint\n", encoding="utf-8")

    health = perform_healthchecks()
    entry = {
        "ts": ts,
        "action": "boot_now",
        "hash": sha256(CHECKPOINT),
        "env_created": env_created,
        "health": health,
    }
    append_log(entry)

    note = notify_grok({"service": "Menir", "event": "boot_now", "ts": ts, "hash": entry["hash"]})
    print(json.dumps({**entry, "notify": note}))

if __name__ == "__main__":
    main()