"""Thin wrapper delegating to the canonical implementation in the
`menir10` package. This file preserves the top-level test-facing API so
existing tests and scripts that import `menir10_export` at repo root
continue to work while the canonical implementation lives in
`menir10/menir10_export.py`.

Where possible the wrapper delegates; for a few small helpers there is
an internal fallback to remain robust if the package import fails.
"""

from __future__ import annotations

from typing import Iterable, List, Dict, Any

try:
    # canonical implementation
    from menir10 import menir10_export as _canonical
    from menir10 import menir10_insights as _insights
except Exception:  # pragma: no cover - fallback for import errors
    _canonical = None
    _insights = None


def group_by_project(entries: Iterable[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
    if _insights is not None and hasattr(_insights, "group_by_project"):
        return _insights.group_by_project(list(entries))

    # fallback
    from collections import defaultdict

    grouped: Dict[str, List[Dict[str, Any]]] = defaultdict(list)
    for e in entries:
        pid = e.get("project_id", "unknown")
        grouped[pid].append(e)
    return dict(grouped)


def top_projects(entries: Iterable[Dict[str, Any]], limit: int = 5) -> List[tuple]:
    if _insights is not None and hasattr(_insights, "list_top_projects"):
        return _insights.list_top_projects(list(entries), top_n=limit)

    from collections import Counter

    c = Counter()
    for e in entries:
        c[e.get("project_id", "unknown")] += 1
    return c.most_common(limit)


def generate_cypher(entries: Iterable[Dict[str, Any]], label: str = "PerceptionState") -> str:
    # prefer canonical name if available
    if _canonical is not None:
        if hasattr(_canonical, "generate_cypher"):
            return _canonical.generate_cypher(entries, label=label)
        if hasattr(_canonical, "generate_cypher_interactions"):
            return _canonical.generate_cypher_interactions(entries, label=label)

    # basic fallback implementation
    def _escape(s: str) -> str:
        return str(s).replace("'", "\\'")

    entries = list(entries)
    grouped = group_by_project(entries)
    lines = ["// Generated by menir10_export (fallback)"]

    for project in grouped.keys():
        lines.append(f"CREATE (p_{project} :Project {{ name: '{_escape(project)}' }});")

    for e in entries:
        iid = e.get("interaction_id")
        pid = e.get("project_id")
        content = e.get("content", "")
        lines.append(
            f"CREATE (i_{iid} :Interaction {{ id: '{_escape(str(iid))}', content: '{_escape(str(content))}' }});"
        )
        lines.append(
            f"MATCH (p:Project {{ name: '{_escape(pid)}' }}), (i:Interaction {{ id: '{_escape(str(iid))}' }}) CREATE (p)-[:HAS_INTERACTION]->(i);"
        )

    return "\n".join(lines)


def generate_daily_report_md(entries: Iterable[Dict[str, Any]], target_date, top_n: int = 5, per_project_limit: int = 10) -> str:
    # delegate to canonical if present
    if _canonical is not None and hasattr(_canonical, "generate_daily_report_md"):
        return _canonical.generate_daily_report_md(entries, target_date, top_n=top_n, per_project_limit=per_project_limit)

    # fallback: reproduce the expected structure
    from datetime import datetime
    from collections import Counter

    def _parse_iso_date(ts: str):
        if not ts:
            return None
        if ts.endswith("Z"):
            ts = ts[:-1] + "+00:00"
        try:
            return datetime.fromisoformat(ts).date()
        except Exception:
            try:
                return datetime.strptime(ts[:10], "%Y-%m-%d").date()
            except Exception:
                return None

    entries = list(entries)
    filtered = [e for e in entries if _parse_iso_date(e.get("ts", "")) == target_date]
    total = len(filtered)
    lines = ["Menir10 Daily Report", "", f"- Total interactions: {total}", ""]
    grouped = group_by_project(filtered)
    top = Counter({k: len(v) for k, v in grouped.items()}).most_common(top_n)

    for project_id, count in top:
        lines.append(f"## {project_id}")
        lines.append(f"- Count: {count}")
        for interaction in grouped.get(project_id, [])[:per_project_limit]:
            ts = interaction.get("ts")
            role = interaction.get("role")
            content = interaction.get("content", "")
            lines.append(f"- {ts} | {role} | {content}")
        lines.append("")

    return "\n".join(lines)


def load_entries_from_jsonl(path):
    if _canonical is not None:
        if hasattr(_canonical, "load_entries_from_jsonl"):
            return _canonical.load_entries_from_jsonl(path)
        if hasattr(_canonical, "load_logs"):
            return _canonical.load_logs(path)

    # basic fallback: read JSONL using pathlib
    import json
    from pathlib import Path

    p = Path(path)
    if not p.exists():
        return []
    out = []
    with p.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            out.append(json.loads(line))
    return out


def main() -> None:
    if _canonical is not None and hasattr(_canonical, "main"):
        return _canonical.main()
    print("No canonical menir10 export available.")


if __name__ == "__main__":
    main()
